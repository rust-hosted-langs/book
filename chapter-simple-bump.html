<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Bump allocation - Writing Interpreters in Rust: a Guide</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="part-allocators.html"><strong aria-hidden="true">2.</strong> Allocation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter-alignment.html"><strong aria-hidden="true">2.1.</strong> Alignment</a></li><li class="chapter-item expanded "><a href="chapter-blocks.html"><strong aria-hidden="true">2.2.</strong> Obtaining blocks of memory</a></li><li class="chapter-item expanded "><a href="chapter-what-is-alloc.html"><strong aria-hidden="true">2.3.</strong> The type of allocation</a></li></ol></li><li class="chapter-item expanded "><a href="part-stickyimmix.html"><strong aria-hidden="true">3.</strong> An allocator: Sticky Immix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter-simple-bump.html" class="active"><strong aria-hidden="true">3.1.</strong> Bump allocation</a></li><li class="chapter-item expanded "><a href="chapter-managing-blocks.html"><strong aria-hidden="true">3.2.</strong> Allocating into multiple blocks</a></li><li class="chapter-item expanded "><a href="chapter-allocation-api.html"><strong aria-hidden="true">3.3.</strong> Defining the allocation API</a></li><li class="chapter-item expanded "><a href="chapter-allocation-impl.html"><strong aria-hidden="true">3.4.</strong> Implementing the API</a></li></ol></li><li class="chapter-item expanded "><a href="part-interpreter.html"><strong aria-hidden="true">4.</strong> An interpreter: Eval-rs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter-interp-alloc.html"><strong aria-hidden="true">4.1.</strong> Allocating objects and dereferencing safely</a></li><li class="chapter-item expanded "><a href="chapter-interp-tagged-ptrs.html"><strong aria-hidden="true">4.2.</strong> Tagged pointers and object headers</a></li><li class="chapter-item expanded "><a href="chapter-interp-symbols-and-pairs.html"><strong aria-hidden="true">4.3.</strong> Symbols and Pairs</a></li><li class="chapter-item expanded "><a href="chapter-interp-parsing.html"><strong aria-hidden="true">4.4.</strong> Parsing s-expressions</a></li><li class="chapter-item expanded "><a href="chapter-interp-arrays.html"><strong aria-hidden="true">4.5.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="chapter-interp-bytecode.html"><strong aria-hidden="true">4.6.</strong> Bytecode</a></li><li class="chapter-item expanded "><a href="chapter-interp-dicts.html"><strong aria-hidden="true">4.7.</strong> Dicts</a></li><li class="chapter-item expanded "><a href="chapter-interp-vm-design.html"><strong aria-hidden="true">4.8.</strong> Virtual Machine: Design</a></li><li class="chapter-item expanded "><a href="chapter-interp-vm-impl.html"><strong aria-hidden="true">4.9.</strong> Virtual Machine: Implementation</a></li><li class="chapter-item expanded "><a href="chapter-interp-compiler-design.html"><strong aria-hidden="true">4.10.</strong> Compiler: Design</a></li><li class="chapter-item expanded "><a href="chapter-interp-compiler-impl.html"><strong aria-hidden="true">4.11.</strong> Compiler: Implementation</a></li></ol></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">5.</strong> Garbage collection</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">5.1.</strong> TODO - Tracing</a></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">5.2.</strong> TODO - Sweeping</a></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">5.3.</strong> TODO - Recycling blocks</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Writing Interpreters in Rust: a Guide</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#bump-allocation" id="bump-allocation">Bump allocation</a></h1>
<p>Now that we can get blocks of raw memory, we need to write objects into it. The
simplest way to do this is to write objects into a block one after the other
in consecutive order. This is bump allocation - we have a pointer, the bump
pointer, which points at the space in the block after the last object that
was written. When the next object is written, the bump pointer is incremented
to point to the space after <em>that</em> object.</p>
<p>In a twist of mathematical convenience, though, it is <a href="https://fitzgeraldnick.com/2019/11/01/always-bump-downwards.html">more efficient</a> to
bump allocate from a high memory location <em>downwards</em>. We will do that.</p>
<p>We will used a fixed power-of-two block size. The benefit of this is that
given a pointer to an object, by zeroing the bits of the pointer that represent
the block size, the result points to the beginning of the block. This will
be useful later when implementing garbage collection.</p>
<p>Our block size will be 32k, a reasonably optimal size arrived at in the
original <a href="http://www.cs.utexas.edu/users/speedway/DaCapo/papers/immix-pldi-2008.pdf">Immix paper</a>. This size can be any power of two though and
different use cases may show different optimal sizes.</p>
<pre><code class="language-rust ignore">pub const BLOCK_SIZE_BITS: usize = 15;
pub const BLOCK_SIZE: usize = 1 &lt;&lt; BLOCK_SIZE_BITS;
</code></pre>
<p>Now we'll define a struct that wraps the block with a bump pointer and garbage
collection metadata:</p>
<pre><code class="language-rust ignore">pub struct BumpBlock {
    cursor: *const u8,
    limit: *const u8,
    block: Block,
    meta: BlockMeta,
}
</code></pre>
<h2><a class="header" href="#bump-allocation-basics" id="bump-allocation-basics">Bump allocation basics</a></h2>
<p>In this struct definition, there are two members that we are interested in
to begin with. The other two, <code>limit</code> and <code>meta</code>, will be discussed in the
next section.</p>
<ul>
<li><code>cursor</code>: this is the bump pointer. In our implementation it is the index
into the block where the last object was written.</li>
<li><code>block</code>: this is the <code>Block</code> itself in which objects will be written.</li>
</ul>
<p>Below is a start to a bump allocation function:</p>
<pre><code class="language-rust ignore">impl BumpBlock {
    pub fn inner_alloc(&amp;mut self, alloc_size: usize) -&gt; Option&lt;*const u8&gt; {
        let block_start_ptr = self.block.as_ptr() as usize;
        let cursor_ptr = self.cursor as usize;

        // align to word boundary
        let align_mask: usize = !(size_of::&lt;usize&gt;() - 1);

        let next_ptr = cursor_ptr.checked_sub(alloc_size)? &amp; align_mask;

        if next_ptr &lt; block_start_ptr {
            // allocation would start lower than block beginning, which means
            // there isn't space in the block for this allocation
            None
        } else {
            self.cursor = next_ptr as *const u8;
            Some(next_ptr as *const u8)
        }
    }
}
</code></pre>
<p>In our function, the <code>alloc_size</code> parameter should be a number of bytes of
memory requested.</p>
<p>The value of <code>alloc_size</code> may produce an unaligned pointer at which to write the
object. Fortunately, by bump allocating downward we can apply a simple mask to the
pointer to align it down to the nearest word:</p>
<pre><code class="language-rust ignore">        let align_mask: usize = !(size_of::&lt;usize&gt;() - 1);
</code></pre>
<p>In initial implementation, allocation will simply return <code>None</code> if the block
does not have enough capacity for the requested <code>alloc_size</code>. If there <em>is</em>
space, it will be returned as a <code>Some(*const u8)</code> pointer.</p>
<p>Note that this function does not <em>write</em> the object to memory, it merely
returns a pointer to an available space.  Writing the object will require
invoking the <code>std::ptr::write</code> function. We will do that in a separate module
but for completeness of this chapter, this might look something like:</p>
<pre><code class="language-rust ignore">use std::ptr::write;

unsafe fn write&lt;T&gt;(dest: *const u8, object: T) {
    write(dest as *mut T, object);
}
</code></pre>
<h2><a class="header" href="#some-time-passes" id="some-time-passes">Some time passes...</a></h2>
<p>After allocating and freeing objects, we will have gaps between objects in a
block that can be reused. The above bump allocation algorithm is unaware of
these gaps so we'll have to modify it before it can allocate into fragmented
blocks.</p>
<p>To recap, in Immix, a block is divided into lines and only whole lines are
considered for reuse. When objects are marked as live, so are the lines that an
object occupies. Therefore, only lines that are <em>not</em> marked as live are usable
for allocation into. Even if a line is only partially allocated into, it is not
a candidate for further allocation.</p>
<p>In our implementation we will use the high bytes of the <code>Block</code> to represent
these line mark bits, where each line is represented by a single byte.</p>
<p>We'll need a data structure to represent this. we'll call it <code>BlockMeta</code>,
but first some constants that we need in order to know</p>
<ul>
<li>how big a line is</li>
<li>how many lines are in a block</li>
<li>how many bytes remain in the <code>Block</code> for allocating into</li>
</ul>
<pre><code class="language-rust ignore">pub const LINE_SIZE_BITS: usize = 7;
pub const LINE_SIZE: usize = 1 &lt;&lt; LINE_SIZE_BITS;

// How many total lines are in a block
pub const LINE_COUNT: usize = BLOCK_SIZE / LINE_SIZE;

// We need LINE_COUNT number of bytes for marking lines, so the capacity of a block
// is reduced by that number of bytes.
pub const BLOCK_CAPACITY: usize = BLOCK_SIZE - LINE_COUNT;
</code></pre>
<p>For clarity, let's put some numbers to the definitions we've made so far:</p>
<ul>
<li>A block size is 32Kbytes</li>
<li>A line is 128 bytes long</li>
<li>The number of lines within a 32Kbyte <code>Block</code> is 256</li>
</ul>
<p>Therefore the top 256 bytes of a <code>Block</code> are used for line mark bits. Since
these line mark bits do not need to be marked themselves, the last <em>two bytes</em>
of the <code>Block</code> are not needed to mark lines.</p>
<p>This leaves one last thing to mark: the entire <code>Block</code>. If <em>any</em> line in the
<code>Block</code> is marked, then the <code>Block</code> is considered to be live and must be marked
as such.</p>
<p>We use the final byte of the <code>Block</code> to store the <code>Block</code> mark bit.</p>
<p>The definition of <code>BumpBlock</code> contains member <code>meta</code> which is of type
<code>BlockMeta</code>. We can now introduce the definition of <code>BlockMeta</code> which we simply
need to represent a pointer to the line mark section at the end of the <code>Block</code>:</p>
<pre><code class="language-rust ignore">pub struct BlockMeta {
    lines: *mut u8,
}
</code></pre>
<p>This pointer could be easily calculated, of course, so this is just a handy
shortcut.</p>
<h3><a class="header" href="#allocating-into-a-fragmented-block" id="allocating-into-a-fragmented-block">Allocating into a fragmented Block</a></h3>
<p><img src="img/fragmented_block.png" alt="StickyImmix Fragmented Block" /></p>
<p>The struct <code>BlockMeta</code> contains one function we will study:</p>
<pre><code class="language-rust ignore">    /// When it comes to finding allocatable holes, we bump-allocate downward.
    pub fn find_next_available_hole(
        &amp;self,
        starting_at: usize,
        alloc_size: usize,
    ) -&gt; Option&lt;(usize, usize)&gt; {
        // The count of consecutive avaliable holes. Must take into account a conservatively marked
        // hole at the beginning of the sequence.
        let mut count = 0;
        let starting_line = starting_at / constants::LINE_SIZE;
        let lines_required = (alloc_size + constants::LINE_SIZE - 1) / constants::LINE_SIZE;
        // Counting down from the given search start index
        let mut end = starting_line;

        for index in (0..starting_line).rev() {
            let marked = unsafe { *self.lines.add(index) };

            if marked == 0 {
                // count unmarked lines
                count += 1;

                if index == 0 &amp;&amp; count &gt;= lines_required {
                    let limit = index * constants::LINE_SIZE;
                    let cursor = end * constants::LINE_SIZE;
                    return Some((cursor, limit));
                }
            } else {
                // This block is marked
                if count &gt; lines_required {
                    // But at least 2 previous blocks were not marked. Return the hole, considering the
                    // immediately preceding block as conservatively marked
                    let limit = (index + 2) * constants::LINE_SIZE;
                    let cursor = end * constants::LINE_SIZE;
                    return Some((cursor, limit));
                }

                // If this line is marked and we didn't return a new cursor/limit pair by now,
                // reset the hole search state
                count = 0;
                end = index;
            }
        }

        None
    }
</code></pre>
<p>The purpose of this function is to locate a gap of unmarked lines of sufficient
size to allocate an object of size <code>alloc_size</code> into.</p>
<p>The input to this function, <code>starting_at</code>, is the offset into the block to start
looking for a hole.</p>
<p>If no suitable hole is found, the return value is <code>None</code>.</p>
<p>If there are unmarked lines lower in memory than the <code>starting_at</code> point (bump
allocating downwards), the return value will be a pair of numbers: <code>(cursor, limit)</code> where:</p>
<ul>
<li><code>cursor</code> will be the new bump pointer value</li>
<li><code>limit</code> will be the lower bound of the available hole.</li>
</ul>
<h4><a class="header" href="#a-deeper-dive" id="a-deeper-dive">A deeper dive</a></h4>
<p>Our first variable is a counter of consecutive available lines. This count will
always assume that the first line in the sequence is conservatively marked and
won't count toward the total, unless it is line 0.</p>
<pre><code class="language-rust ignore">        let mut count = 0;
</code></pre>
<p>Next, the <code>starting_at</code> and <code>alloc_size</code> arguments have units of bytes but we
want to use line count math, so conversion must be done.</p>
<pre><code class="language-rust ignore">         let starting_line = starting_at / constants::LINE_SIZE;
         let lines_required = (alloc_size + constants::LINE_SIZE - 1) / constants::LINE_SIZE;
</code></pre>
<p>Our final variable will be the end line that, together with <code>starting_line</code>,
will mark the boundary of the hole we hope to find.</p>
<pre><code class="language-rust ignore">        let mut end = starting_line;
</code></pre>
<p>Now for the loop that identifies holes and ends the function if either:</p>
<ul>
<li>a large enough hole is found</li>
<li>no suitable hole is found</li>
</ul>
<p>We iterate over lines in decreasing order from <code>starting_line</code> down to line zero
and fetch the mark bit into variable <code>marked</code>.</p>
<pre><code class="language-rust ignore">        for index in (0..starting_line).rev() {
            let marked = unsafe { *self.lines.add(index) };
</code></pre>
<p>If the line is unmarked, we increment our consecutive-unmarked-lines counter.</p>
<p>Then we reach the first termination condition: we reached line zero and we have
a large enough hole for our object. The hole extents can be returned, converting
back to byte offsets.</p>
<pre><code class="language-rust ignore">            if marked == 0 {
                count += 1;

                if index == 0 &amp;&amp; count &gt;= lines_required {
                    let limit = index * constants::LINE_SIZE;
                    let cursor = end * constants::LINE_SIZE;
                    return Some((cursor, limit));
                }
            } else {
</code></pre>
<p>Otherwise if the line is marked, we've reached the end of the current hole (if
we were even over one.)</p>
<p>Here, we have the second possible termination condition: we have a large enough
hole for our object. The hole extents can be returned, taking the last line as
conservatively marked.</p>
<p>This is seen in adding 2 to <code>index</code>:</p>
<ul>
<li>1 for walking back from the current marked line</li>
<li>plus 1 for walking back from the previous conservatively marked line</li>
</ul>
<p>If this condition isn't met, our search is reset - <code>count</code> is back to zero and
we keep iterating.</p>
<pre><code class="language-rust ignore">            } else {
                if count &gt; lines_required {
                    let limit = (index + 2) * constants::LINE_SIZE;
                    let cursor = end * constants::LINE_SIZE;
                    return Some((cursor, limit));
                }

                count = 0;
                end = index;
            }
</code></pre>
<p>Finally, if iterating over lines reached line zero without finding a hole, we
return <code>None</code> to indicate failure.</p>
<pre><code class="language-rust ignore">        }

        None
    }
</code></pre>
<h4><a class="header" href="#making-use-of-the-hole-finder" id="making-use-of-the-hole-finder">Making use of the hole finder</a></h4>
<p>We'll return to the <code>BumpBlock::inner_alloc()</code> function now to make use of
<code>BlockMeta</code> and its hole finding operation.</p>
<p>The <code>BumpBlock</code> struct contains two more members: <code>limit</code> and <code>meta</code>. These
should now be obvious - <code>limit</code> is the known byte offset limit into which
we can allocate, and <code>meta</code> is the <code>BlockMeta</code> instance associated with the
block.</p>
<p>We need to update <code>inner_alloc()</code> with a new condition:</p>
<ul>
<li>the size being requested must fit between <code>self.cursor</code> and <code>self.limit</code></li>
</ul>
<p>(Note that for a fresh, new block, <code>self.limit</code> is set to the block size.)</p>
<p>If the above condition is not met, we will call
<code>BlockMeta::find_next_available_hole()</code> to get a new <code>cursor</code> and <code>limit</code>
to try, and repeat that until we've either <em>found</em> a big enough hole or
reached the end of the block, exhausting our options.</p>
<p>The new definition of <code>BumpBlock::inner_alloc()</code> reads as follows:</p>
<pre><code class="language-rust ignore">    pub fn inner_alloc(&amp;mut self, alloc_size: usize) -&gt; Option&lt;*const u8&gt; {
        let ptr = self.cursor as usize;
        let limit = self.limit as usize;

        let next_ptr = ptr.checked_sub(alloc_size)? &amp; constants::ALLOC_ALIGN_MASK;

        if next_ptr &lt; limit {
            let block_relative_limit =
                unsafe { self.limit.sub(self.block.as_ptr() as usize) } as usize;

            if block_relative_limit &gt; 0 {
                if let Some((cursor, limit)) = self
                    .meta
                    .find_next_available_hole(block_relative_limit, alloc_size)
                {
                    self.cursor = unsafe { self.block.as_ptr().add(cursor) };
                    self.limit = unsafe { self.block.as_ptr().add(limit) };
                    return self.inner_alloc(alloc_size);
                }
            }

            None
        } else {
            self.cursor = next_ptr as *const u8;
            Some(self.cursor)
        }
    }
</code></pre>
<p>and as you can see, this implementation is recursive.</p>
<h2><a class="header" href="#wrapping-this-up" id="wrapping-this-up">Wrapping this up</a></h2>
<p>At the beginning of this chapter we stated that given a pointer to an object, by
zeroing the bits of the pointer that represent the block size, the result points
to the beginning of the block.</p>
<p>We'll make use of that now.</p>
<p>During the mark phase of garbage collection, we will need to know which line or
lines to mark, in addition to marking the object itself. We will make a copy of
the <code>BlockMeta</code> instance pointer in the 0th word of the memory block so that
given any object pointer, we can obtain the <code>BlockMeta</code> instance.</p>
<p>In the next chapter we'll handle multiple <code>BumpBlock</code>s so that we can keep
allocating objects after one block is full.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="part-stickyimmix.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="chapter-managing-blocks.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="part-stickyimmix.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="chapter-managing-blocks.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
